function solutions = FindRoots(f,lower_bound,upper_bound) 
    tol = 1e-7; %Used to avoid double-counting roots
    solutions = [];
    stack = {[lower_bound,upper_bound]};
    while ~isempty(stack)
        interval = stack{end};
        stack(end) = [];
        l = interval(1);
        u = interval(2);
        if f(l)*f(u) < 0 %Checks if fzero can be run in this case
           [X,FVAL,EXITFLAG] = fzero(f,[l,u]);
           if EXITFLAG > 0
               solutions = [solutions, X];
               stack = [stack,{[l, X-tol]}];
               stack = [stack, {[X+tol, u]}];
               %Bisects the interval into two disjoint intervals, then searches those for roots
           end
           if EXITFLAG <= 0 %Handles errors
               disp('Warning: fsolve failed; printing EXITFLAG in next line')
               disp(EXITFLAG)
           end
       else
           %Given the endpoints of the interval both give outputs of the same sign (say, positive),
           %we then check the minimum between the two to see if any roots exist
           if f(l) > 0
               X = fminbnd(f,l,u); 
               if f(X) < 0
                   stack = [stack,{[l, X-tol]}];
                   stack = [stack, {[X+tol, u]}];
                   %Bisects the interval into two disjoint intervals, then searches those for roots
               end
           else
               g = @(x) -f(x); %MATLAB has no 'fmaxbnd' function so we must
               %multiply everything by -1, then proceed as above
               X = fminbnd(g,l,u); 
               if f(X) > 0
                   stack = [stack,{[l, X-tol]}];
                   stack = [stack, {[X+tol, u]}];
                   %Bisects the interval into two disjoint intervals, then searches those for roots
               end

           end
       end
    end
end

N = 2; %Number of species

% Here you input your equations for r(M) as a vector, with
% each entry being each r_i
function r_result = r(M)
    r_result = [
        sech(M-5) - 0.2;
        sech(M-6) - 0.2];
end

% Here you input your equations for r'(M) as vector, calculated
% by hand, with each entry being each r_i'
function r_dash_result = rdash(M)
    r_dash_result = [
        -tanh(M-5)*sech(M-5);
        -tanh(M-6)*sech(M-6)];
end

function r_s = reduced(vectorfunction, indices,M)
   r_s = vectorfunction(M);
   r_s = r_s(indices);
end

%Equilibrium equation
function eq = eqsolve(M,A,I,P,R,N)
    eq = I - M(1 + P*ones(1,N)*(A\R));
end

% Jacobian function
function jac = Jacobian(C_vec,M,A_mat,I,P)
    first_vec = r(M) - A_mat * C_vec;
    top_left = - A_mat.*C_vec + diag(first_vec);    
    top_right = C_vec.*rdash(M);
    bottom_left = -P*M*ones(1,length(C_vec));
    bottom_right = -I/M;
    top = [top_left,top_right];
    bottom = [bottom_left,bottom_right];
    jac = [top;bottom];
end


% Here you describe your matrix for A. This is a square matrix of whichever
% dimension you choose.
A = [0.5, 0;
0, 5];

% Define your I and P
% I = 
% P =

% Here you choose the length and width of the plots
x_min = 0.01;
x_max = 4;
y_min = 0.01;
y_max = 30;


% Here you choose how many points you want to create on each axis
x_num_points = 10;
y_num_points = 10;

% This is a matrix containing the 'colours' we want to plot for each point.
% This will be filled with various numbers by the end
colours = zeros(x_num_points,y_num_points);

ynum=0;
% 6a - PLACE THE PARAMETER YOU WANT ON THE Y-AXIS HERE
for I = linspace(y_min,y_max,y_num_points)
    ynum = ynum + 1;
    xnum = 0;
    % 6b - PLACE THE PARAMETER YOU WANT ON THE X-AXIS HERE 
    % (Final instruction)
    for P = linspace(x_min,x_max,x_num_points)
        xnum = xnum + 1;
        
        colour = zeros(1,N);
        %Counter cycles through all combinations of non-extinct species
        for j = 1:2^N-1 
            i = j;
            index = N;
            vect = zeros(1, N);   
            while i > 0
                vect(index) = mod(i, 2); 
                i = floor(i / 2); 
                index = index - 1; 
            end %Converts to a binary vector
            disp('vect')
            disp(vect)
            eqno = sum(vect); % The number of species that are alive
            disp('eqno')
            disp(eqno)
            index_set = find(vect); %Converts binary vector to index set
            disp('index_set')
            disp(index_set)
            As = A(index_set,index_set);
            rs = @(M) reduced(r, index_set, M);
            disp('As')
            disp(As)
            disp('rs')
            disp(rs)
            rsderiv = @(M) reduced(rdash, index_set, M); %Sets relevant submatrices and vector functions
   
            G = @(M) eqsolve(M,As,I,P,rs,N);
            for root = FindRoots(G,0,I)
                 C_vect = As\r(root);% Find the equilibrium's co-ordinate
                 if all(C_vect >= 0) % Checks feasibility
                     J_num = Jacobian(C_vect,root,A,I,P); % Calculates the Jacobian
                     eigenvalues = real(eig(J_num)); % Find the real eigenvalues
                     if all(eigenvalues < 0) % Check real parts are negative
                         colour(eqno) = colour(eqno) + 1; %If so, increase the number of stable coexistence equilibria by 1
                     end
                 end
            end

            disp(colour)


        end
    end
end

% COLOURS HERE

% COLOR MAP HERE
customColorMap = [
    0, 0 ,0;
    1, 1, 1;
    ];


%Plot the points using imagesc
%yspace = linspace(ymin,ymax,y_num_points);
%xspace = linspace(xmin,xmax,x_num_points);
%figure;
%colormap(customColorMap)
%imagesc(xspace,yspace,colours)
%set(gca, 'CLim', [0 length(customColorMap) - 1]);
%axis xy
%colorbar;
%toc
